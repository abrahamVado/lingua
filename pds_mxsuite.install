<?php

use Drupal\Core\Logger\LoggerChannelInterface;
use Drupal\Core\Recipe\Recipe;
use Drupal\Core\Recipe\RecipeRunner;

/**
 * Implements hook_install().
 *
 * On fresh install of pds_mxsuite:
 * - Create DB tables needed by suite (group and item tables for template content).
 * - Run bundled recipes.
 */
function pds_mxsuite_install(): void {
  // 1. Ensure required tables exist on fresh install.
  _pds_mxsuite_create_tables();

  // 2. Apply recipes (your existing logic).
  $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
  $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
  $dirs = ['fondos_mutuos','educacion_financiera'];

  foreach ($dirs as $dir) {
    $path = $base . '/' . $dir;
    if (!is_dir($path)) {
      \Drupal::logger('pds_mxsuite')->warning('Recipe missing: @dir', ['@dir' => $dir]);
      continue;
    }
    try {
      $recipe = Recipe::createFromDirectory($path);
      RecipeRunner::processRecipe($recipe);
      \Drupal::logger('pds_mxsuite')->info('Recipe applied: @dir', ['@dir' => $dir]);
    }
    catch (\Throwable $e) {
      \Drupal::logger('pds_mxsuite')->error('Recipe @dir failed: @m', [
        '@dir' => $dir,
        '@m' => $e->getMessage(),
      ]);
    }
  }
}

/**
 * Implements hook_schema().
 */
function pds_mxsuite_schema(): array {
  //1.- Hand Drupal the canonical schema so core can manage installs and updates.
  $definitions = _pds_mxsuite_get_table_definitions();

  //2.- Return the subset keyed by table name to satisfy the hook contract.
  return [
    'pds_template_group' => $definitions['pds_template_group'],
    'pds_template_item' => $definitions['pds_template_item'],
  ];
}

/**
 * Shared helper.
 *
 * Creates the two core tables:
 * - pds_template_group
 * - pds_template_item
 *
 * Safe to call multiple times. It will skip if tables already exist.
 */
function _pds_mxsuite_create_tables(): void {
  $schema = \Drupal::database()->schema();
  $definitions = _pds_mxsuite_get_table_definitions();

  // Master table = one component/group instance.
  if (!$schema->tableExists('pds_template_group')) {
    $schema->createTable('pds_template_group', $definitions['pds_template_group']);
  }

  // Child table = many cards per group.
  if (!$schema->tableExists('pds_template_item')) {
    $schema->createTable('pds_template_item', $definitions['pds_template_item']);
  }
}

/**
 * Build the canonical table definitions used across install-time helpers.
 */
function _pds_mxsuite_get_table_definitions(): array {
  //1.- Describe the group table exactly once so schema(), install(), and repairs share it.
  $group_definition = [
    'description' => 'Logical group of template items (one rendered component instance).',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'type' => [
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        // e.g. "pds_recipe_executives"
        //      "pds_recipe_formas_de_invertir"
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'type' => ['type'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //2.- Mirror the runtime expectations for items so every code path provisions the same schema.
  $item_definition = [
    'description' => 'Items/cards that belong to a template group.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'group_id' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        // FK to pds_template_group.id
      ],
      'weight' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'header' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'subheader' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'description' => [
        'type' => 'text',
        'size' => 'big',
        'not null' => FALSE,
      ],
      'url' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'desktop_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'mobile_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'latitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'longitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'group_id' => ['group_id'],
      'weight' => ['weight'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //3.- Cache the definitions in memory for the current request so repeated calls stay cheap.
  return [
    'pds_template_group' => $group_definition,
    'pds_template_item' => $item_definition,
  ];
}

/**
 * Include the schema repairer class when the container cannot autoload it.
 */
function _pds_mxsuite_include_schema_repairer(?LoggerChannelInterface $logger = NULL): bool {
  //1.- Skip the include work when the class is already present in memory.
  if (class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer')) {
    return TRUE;
  }

  try {
    //2.- Look up the module path dynamically so multisite installs remain compatible.
    $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_template');
    if (is_string($module_path) && $module_path !== '') {
      $legacy_repairer_path = DRUPAL_ROOT . '/' . $module_path . '/src/Service/LegacySchemaRepairer.php';
      if (is_readable($legacy_repairer_path)) {
        require_once $legacy_repairer_path;
      }
    }
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to include schema repairer class manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //3.- Report whether the class could be loaded so callers can attempt manual instantiation.
  return class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer');
}

/**
 * Build the schema repairer without the service container when necessary.
 */
function _pds_mxsuite_build_schema_repairer(?LoggerChannelInterface $logger = NULL): ?object {
  //1.- Ensure the class definition is available before attempting instantiation.
  if (!_pds_mxsuite_include_schema_repairer($logger)) {
    return NULL;
  }

  try {
    //2.- Construct the repairer directly so update hooks can run during cache rebuilds.
    return new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
      \Drupal::database(),
      \Drupal::service('datetime.time'),
      \Drupal::service('uuid'),
      \Drupal::service('logger.factory')
    );
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to instantiate schema repairer manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
    return NULL;
  }
}

/**
 * Cleanup dup config and re-run recipes.
 *
 * This is your existing update 8013.
 */
function pds_mxsuite_update_8013(): void {
  $dups = ['pds_recipe_fondos_mutuos.settings']; // la que choca
  foreach ($dups as $name) {
    $conf = \Drupal::config($name);
    if (!$conf->isNew()) {
      \Drupal::logger('pds_mxsuite')->warning(
        'Deleting existing config @c to prevent collision.',
        ['@c' => $name]
      );
      \Drupal::configFactory()->getEditable($name)->delete();
    }
  }

  // Reapply recipes or install modules depending on platform.
  if (class_exists('\Drupal\Core\Recipe\Recipe')) {
    $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
    $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
    foreach ([
      'pds_fondos_mutuos',
      'pds_educacion_financiera',
      'pds_recipe_formas_de_invertir',
      'pds_recipe_mapa',
      'pds_recipe_executives',
      'pds_recipe_slider_banner',
      'pds_recipe_template',
    ] as $dir) {
      $path = $base . '/' . $dir;
      if (is_dir($path)) {
        $r = \Drupal\Core\Recipe\Recipe::createFromDirectory($path);
        \Drupal\Core\Recipe\RecipeRunner::processRecipe($r);
      }
    }
  }
  else {
    \Drupal::service('module_installer')->install([
      'pds_recipe_fondos_mutuos',
      'pds_recipe_educacion_financiera',
      'pds_recipe_formas_de_invertir',
      'pds_recipe_mapa',
      'pds_recipe_executives',
      'pds_recipe_slider_banner',
      'pds_recipe_template',
    ], TRUE);
  }
}

/**
 * New update hook to backfill the tables on sites where pds_mxsuite
 * is already enabled and running.
 *
 * This will run once when you deploy this code
 * and execute `drush updb` or load /update.php.
 */
function pds_mxsuite_update_9010(): void {
  _pds_mxsuite_create_tables();

  \Drupal::logger('pds_mxsuite')->notice(
    'Ensured pds_template_group and pds_template_item tables exist.'
  );
}

/**
 * Ensure legacy template tables are upgraded to the new schema.
 */
function pds_mxsuite_update_9012(): void {
  //1.- Create missing tables first so the schema repairer can safely rebuild them.
  _pds_mxsuite_create_tables();

  $logger = \Drupal::logger('pds_mxsuite');
  $repairer = NULL;

  //2.- Run the runtime repairer when the pds_recipe_template module is available.
  if (\Drupal::hasService('pds_recipe_template.legacy_schema_repairer')) {
    if (!_pds_mxsuite_include_schema_repairer($logger)) {
      $logger->error('Unable to load schema repairer class via the service container.');
    }
    try {
      //3.- Defer to the registered service so shared state remains consistent.
      $repairer = \Drupal::service('pds_recipe_template.legacy_schema_repairer');
    }
    catch (\Throwable $throwable) {
      $logger->error('Unable to load schema repairer service during update 9011: @message', [
        '@message' => $throwable->getMessage(),
      ]);
      $repairer = NULL;
    }
  }
  else {
    //3.- Attempt to include the repairer class explicitly when the module is disabled during database updates.
    if (!class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer')) {
      try {
        //4.- Resolve the module path dynamically so the installer works in any docroot layout.
        $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_template');
        if (is_string($module_path) && $module_path !== '') {
          $legacy_repairer_path = DRUPAL_ROOT . '/' . $module_path . '/src/Service/LegacySchemaRepairer.php';
          if (is_readable($legacy_repairer_path)) {
            require_once $legacy_repairer_path;
          }
        }
      }
      catch (\Throwable $throwable) {
        $logger->error('Unable to include schema repairer during update 9011: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
    }

    if (class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer')) {
      //5.- Instantiate the repairer manually when the module service container is unavailable during updates.
      $repairer = new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
        \Drupal::database(),
        \Drupal::service('datetime.time'),
        \Drupal::service('uuid'),
        \Drupal::service('logger.factory')
      );
    }
  }

  if ($repairer) {
    //6.- Stop early when the repairer reports success so the deployment log highlights the completed check.
    if ($repairer->ensureItemTableUpToDate()) {
      $logger->notice(
        'Verified pds_template_item schema after installing the consolidated update.'
      );
      return;
    }

    //7.- Warn administrators when the rebuild fails so they can inspect dblog for details.
    $logger->warning(
      'Unable to refresh the pds_template_item schema automatically. Check recent log messages for the exact cause.'
    );
    return;
  }

  //8.- Flag the absence of the repairer so site owners know manual intervention is required.
  $logger->warning(
    'The pds_recipe_template schema repairer is unavailable. Manually review the pds_template_item table for legacy columns such as link or image_url.'
  );
}

/**
 * Force a clean rebuild of the recipe template tables.
 */
function pds_mxsuite_update_9015(): void {
  //1.- Drop dependent tables first so stale schema fragments never survive the rebuild.
  $schema = \Drupal::database()->schema();
  foreach (['pds_template_item', 'pds_template_group'] as $table) {
    if ($schema->tableExists($table)) {
      $schema->dropTable($table);
    }
  }

  //2.- Recreate the tables from the canonical helper so new installs and updates stay aligned.
  _pds_mxsuite_create_tables();

  //3.- Log the rebuild outcome so operators can confirm the tables were recreated.
  \Drupal::logger('pds_mxsuite')->notice(
    'Rebuilt pds_template_group and pds_template_item via update 9012.'
  );
}
