<?php

use Drupal\Core\Logger\LoggerChannelInterface;
use Drupal\Core\Recipe\Recipe;
use Drupal\Core\Recipe\RecipeRunner;

/**
 * Implements hook_install().
 *
 * On fresh install of pds_mxsuite:
 * - Create DB tables needed by suite (group and item tables for template content).
 * - Run bundled recipes.
 */
function pds_mxsuite_install(): void {
  // 1. Ensure required tables exist on fresh install.
  _pds_mxsuite_create_tables();

  // 2. Apply recipes (your existing logic).
  $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
  $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
  $dirs = ['fondos_mutuos','educacion_financiera'];

  foreach ($dirs as $dir) {
    $path = $base . '/' . $dir;
    if (!is_dir($path)) {
      \Drupal::logger('pds_mxsuite')->warning('Recipe missing: @dir', ['@dir' => $dir]);
      continue;
    }
    try {
      $recipe = Recipe::createFromDirectory($path);
      RecipeRunner::processRecipe($recipe);
      \Drupal::logger('pds_mxsuite')->info('Recipe applied: @dir', ['@dir' => $dir]);
    }
    catch (\Throwable $e) {
      \Drupal::logger('pds_mxsuite')->error('Recipe @dir failed: @m', [
        '@dir' => $dir,
        '@m' => $e->getMessage(),
      ]);
    }
  }
}

/**
 * Implements hook_schema().
 */
function pds_mxsuite_schema(): array {
  //1.- Hand Drupal the canonical schema so core can manage installs and updates.
  $definitions = _pds_mxsuite_get_table_definitions();

  //2.- Return the subset keyed by table name to satisfy the hook contract.
  return [
    'pds_template_group' => $definitions['pds_template_group'],
    'pds_template_item' => $definitions['pds_template_item'],
    'pds_template_item_timeline' => $definitions['pds_template_item_timeline'],
  ];
}

/**
 * Shared helper.
 *
 * Creates the two core tables:
 * - pds_template_group
 * - pds_template_item
 *
 * Safe to call multiple times. It will skip if tables already exist.
 */
function _pds_mxsuite_create_tables(): void {
  $schema = \Drupal::database()->schema();
  $definitions = _pds_mxsuite_get_table_definitions();

  // Master table = one component/group instance.
  if (!$schema->tableExists('pds_template_group')) {
    $schema->createTable('pds_template_group', $definitions['pds_template_group']);
  }

  // Child table = many cards per group.
  if (!$schema->tableExists('pds_template_item')) {
    $schema->createTable('pds_template_item', $definitions['pds_template_item']);
  }

  // Timeline table = optional milestones associated with an item.
  if (!$schema->tableExists('pds_template_item_timeline')) {
    $schema->createTable('pds_template_item_timeline', $definitions['pds_template_item_timeline']);
  }
}

/**
 * Build the canonical table definitions used across install-time helpers.
 */
function _pds_mxsuite_get_table_definitions(): array {
  //1.- Describe the group table exactly once so schema(), install(), and repairs share it.
  $group_definition = [
    'description' => 'Logical group of template items (one rendered component instance).',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'type' => [
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        // e.g. "pds_recipe_executives"
        //      "pds_recipe_formas_de_invertir"
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'type' => ['type'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //2.- Mirror the runtime expectations for items so every code path provisions the same schema.
  $item_definition = [
    'description' => 'Items/cards that belong to a template group.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'group_id' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        // FK to pds_template_group.id
      ],
      'weight' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'header' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'subheader' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'description' => [
        'type' => 'text',
        'size' => 'big',
        'not null' => FALSE,
      ],
      'url' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'desktop_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'mobile_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'latitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'longitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'group_id' => ['group_id'],
      'weight' => ['weight'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //3.- Describe the timeline helper table so recipes with milestones can persist data.
  $timeline_definition = [
    'description' => 'Timeline segments linked to template items.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'item_id' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'weight' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'year_label' => [
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
        'default' => '',
      ],
      'description' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'indexes' => [
      'item_id' => ['item_id'],
      'weight' => ['weight'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //4.- Cache the definitions in memory for the current request so repeated calls stay cheap.
  return [
    'pds_template_group' => $group_definition,
    'pds_template_item' => $item_definition,
    'pds_template_item_timeline' => $timeline_definition,
  ];
}

/**
 * Include the schema repairer class when the container cannot autoload it.
 */
function _pds_mxsuite_include_schema_repairer(?LoggerChannelInterface $logger = NULL): bool {
  //1.- Delegate to the shared helper when it exists so both modules stay aligned.
  if (function_exists('pds_recipe_template_include_service_class')) {
    if (pds_recipe_template_include_service_class('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer', '/src/Service/LegacySchemaRepairer.php')) {
      return TRUE;
    }
  }

  //2.- Skip the include work when the class is already present in memory.
  if (class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer')) {
    return TRUE;
  }

  try {
    //3.- Look up the module path dynamically so multisite installs remain compatible.
    if (\Drupal::hasService('extension.list.module')) {
      $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_template');
      if (is_string($module_path) && $module_path !== '') {
        $legacy_repairer_path = DRUPAL_ROOT . '/' . $module_path . '/src/Service/LegacySchemaRepairer.php';
        if (is_readable($legacy_repairer_path)) {
          require_once $legacy_repairer_path;
        }
      }
    }
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to include schema repairer class manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //4.- Report whether the class could be loaded so callers can attempt manual instantiation.
  return class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer');
}

/**
 * Build the schema repairer without the service container when necessary.
 */
function _pds_mxsuite_build_schema_repairer(?LoggerChannelInterface $logger = NULL): ?object {
  //1.- Ensure the class definition is available before attempting instantiation.
  if (!_pds_mxsuite_include_schema_repairer($logger)) {
    return NULL;
  }

  try {
    //2.- Construct the repairer directly so update hooks can run during cache rebuilds.
    return new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
      \Drupal::database(),
      \Drupal::service('datetime.time'),
      \Drupal::service('uuid'),
      \Drupal::service('logger.factory')
    );
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to instantiate schema repairer manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
    return NULL;
  }
}

/**
 * Cleanup dup config and re-run recipes.
 *
 * This is your existing update 8013.
 */
function pds_mxsuite_update_8013(): void {
  $dups = ['pds_recipe_fondos_mutuos.settings']; // la que choca
  foreach ($dups as $name) {
    $conf = \Drupal::config($name);
    if (!$conf->isNew()) {
      \Drupal::logger('pds_mxsuite')->warning(
        'Deleting existing config @c to prevent collision.',
        ['@c' => $name]
      );
      \Drupal::configFactory()->getEditable($name)->delete();
    }
  }

  // Reapply recipes or install modules depending on platform.
  if (class_exists('\Drupal\Core\Recipe\Recipe')) {
    $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
    $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
    foreach ([
      'pds_fondos_mutuos',
      'pds_educacion_financiera',
      'pds_recipe_formas_de_invertir',
      'pds_recipe_mapa',
      'pds_recipe_executives',
      'pds_recipe_slider_banner',
      'pds_recipe_template',
    ] as $dir) {
      $path = $base . '/' . $dir;
      if (is_dir($path)) {
        $r = \Drupal\Core\Recipe\Recipe::createFromDirectory($path);
        \Drupal\Core\Recipe\RecipeRunner::processRecipe($r);
      }
    }
  }
  else {
    \Drupal::service('module_installer')->install([
      'pds_recipe_fondos_mutuos',
      'pds_recipe_educacion_financiera',
      'pds_recipe_formas_de_invertir',
      'pds_recipe_mapa',
      'pds_recipe_executives',
      'pds_recipe_slider_banner',
      'pds_recipe_template',
    ], TRUE);
  }
}

/**
 * New update hook to backfill the tables on sites where pds_mxsuite
 * is already enabled and running.
 *
 * This will run once when you deploy this code
 * and execute `drush updb` or load /update.php.
 */
function pds_mxsuite_update_9010(): void {
  _pds_mxsuite_create_tables();

  \Drupal::logger('pds_mxsuite')->notice(
    'Ensured pds_template_group and pds_template_item tables exist.'
  );
}

/**
 * Ensure legacy template tables are upgraded to the new schema.
 */
function pds_mxsuite_update_9012(): void {
  //1.- Create missing tables first so the schema repairer can safely rebuild them.
  _pds_mxsuite_create_tables();

  $logger = \Drupal::logger('pds_mxsuite');
  $repairer = NULL;

  //2.- Reuse the container-managed repairer when the module is enabled.
  if (\Drupal::hasService('pds_recipe_template.legacy_schema_repairer')) {
    if (!_pds_mxsuite_include_schema_repairer($logger)) {
      $logger->error('Unable to load schema repairer class via the service container.');
    }
    try {
      //3.- Defer to the registered service so shared state remains consistent.
      $repairer = \Drupal::service('pds_recipe_template.legacy_schema_repairer');
    }
    catch (\Throwable $throwable) {
      $logger->error('Unable to load schema repairer service during update 9012: @message', [
        '@message' => $throwable->getMessage(),
      ]);
      $repairer = NULL;
    }
  }

  //4.- Fall back to a manual instance when the service is unavailable or failed.
  if (!$repairer) {
    $repairer = _pds_mxsuite_build_schema_repairer($logger);
  }

  if ($repairer) {
    //5.- Stop early when the repairer reports success so the deployment log highlights the completed check.
    if ($repairer->ensureItemTableUpToDate()) {
      $logger->notice(
        'Verified pds_template_item schema after installing the consolidated update.'
      );
      return;
    }

    //6.- Warn administrators when the rebuild fails so they can inspect dblog for details.
    $logger->warning(
      'Unable to refresh the pds_template_item schema automatically. Check recent log messages for the exact cause.'
    );
    return;
  }

  //7.- Flag the absence of the repairer so site owners know manual intervention is required.
  $logger->warning(
    'The pds_recipe_template schema repairer is unavailable. Manually review the pds_template_item table for legacy columns such as link or image_url.'
  );
}

/**
 * Force a clean rebuild of the recipe template tables.
 */
function pds_mxsuite_update_9015(): void {
  //1.- Delegate to the shared rebuild helper so future updates can reuse the routine.
  _pds_mxsuite_rebuild_template_tables('Rebuilt pds_template_group and pds_template_item via update 9015.');
}

/**
 * Drop and recreate the template tables to guarantee a clean schema.
 */
function pds_mxsuite_update_9020(): void {
  //1.- Reuse the rebuild helper so update.php can refresh the tables during this deployment.
  _pds_mxsuite_rebuild_template_tables('Rebuilt pds_template_group and pds_template_item via update 9020.');
}

/**
 * Bring legacy block_uuid based storage in line with group-based tables.
 */
function pds_mxsuite_update_9021(): void {
  //1.- Reuse the canonical schema definitions so installs and updates stay aligned.
  $schema_definition = _pds_mxsuite_get_table_definitions();
  $connection = \Drupal::database();
  $schema = $connection->schema();

  //2.- Provision the master table before migrating item rows.
  if (!$schema->tableExists('pds_template_group')) {
    $schema->createTable('pds_template_group', $schema_definition['pds_template_group']);
  }

  //3.- Create the new item table outright when none exists yet.
  if (!$schema->tableExists('pds_template_item')) {
    $schema->createTable('pds_template_item', $schema_definition['pds_template_item']);
    return;
  }

  //4.- Abort early when deployments already expose the group-aware schema.
  if ($schema->fieldExists('pds_template_item', 'group_id')) {
    return;
  }

  $legacy_table = 'pds_template_item_legacy';

  //5.- Clean up stale leftovers from partial updates before renaming the table.
  if ($schema->tableExists($legacy_table)) {
    $schema->dropTable($legacy_table);
  }

  $schema->renameTable('pds_template_item', $legacy_table);

  //6.- Create the refreshed structure that stores group ids, media URLs and timestamps.
  $schema->createTable('pds_template_item', $schema_definition['pds_template_item']);

  $select = $connection->select($legacy_table, 'legacy')
    ->fields('legacy');

  $result = $select->execute();
  $time_service = \Drupal::time();
  $now = $time_service->getRequestTime();

  foreach ($result as $record) {
    $block_uuid = trim((string) $record->block_uuid);
    $header = trim((string) $record->header);

    if ($block_uuid === '' || $header === '') {
      continue;
    }

    //7.- Create or reuse the matching master record for this legacy block UUID.
    $group_id = \pds_recipe_template_ensure_group_and_get_id($block_uuid, 'pds_recipe_template');
    if (!$group_id) {
      continue;
    }

    $stored_uuid = (string) $record->uuid;
    if (!\Drupal\Component\Uuid\Uuid::isValid($stored_uuid)) {
      $stored_uuid = \Drupal::service('uuid')->generate();
    }

    $image_url = trim((string) $record->image_url);
    $desktop_img = $image_url;
    $mobile_img = $image_url;

    try {
      //8.- Persist the migrated row using the new schema contract.
      $connection->insert('pds_template_item')
        ->fields([
          'uuid' => $stored_uuid,
          'group_id' => (int) $group_id,
          'weight' => (int) $record->weight,
          'header' => $header,
          'subheader' => (string) $record->subheader,
          'description' => (string) $record->description,
          'url' => (string) $record->link,
          'desktop_img' => $desktop_img,
          'mobile_img' => $mobile_img,
          'latitud' => NULL,
          'longitud' => NULL,
          'created_at' => $now,
          'deleted_at' => NULL,
        ])
        ->execute();
    }
    catch (\Throwable) {
      //9.- Skip problematic rows but keep iterating so other records migrate.
      continue;
    }
  }

  //10.- Drop the legacy table once migration is complete to avoid stale state.
  $schema->dropTable($legacy_table);
}

/**
 * Create the timeline segment table for recipes that require milestone tracking.
 */
function pds_mxsuite_update_9022(): void {
  //1.- Keep schema definitions in sync with fresh installs for deterministic deployments.
  $schema_definition = _pds_mxsuite_get_table_definitions();
  $connection = \Drupal::database();
  $schema = $connection->schema();

  if ($schema->tableExists('pds_template_item_timeline')) {
    return;
  }

  //2.- Provision the auxiliary table so timeline-aware recipes can persist milestones.
  $schema->createTable('pds_template_item_timeline', $schema_definition['pds_template_item_timeline']);
}

/**
 * Rebuild legacy tables that missed the earlier schema migration.
 */
function pds_mxsuite_update_9023(): void {
  //1.- Keep the latest schema definition handy so we can compare table layouts quickly.
  $schema_definition = _pds_mxsuite_get_table_definitions();
  $connection = \Drupal::database();
  $schema = $connection->schema();

  //2.- Guarantee the master group table exists before migrating dependent rows.
  if (!$schema->tableExists('pds_template_group')) {
    $schema->createTable('pds_template_group', $schema_definition['pds_template_group']);
  }

  //3.- Provision the refreshed item table outright when no table exists yet.
  if (!$schema->tableExists('pds_template_item')) {
    $schema->createTable('pds_template_item', $schema_definition['pds_template_item']);
    return;
  }

  //4.- Detect missing or legacy columns so the rebuild only runs when schema drift exists.
  $expected_fields = array_keys($schema_definition['pds_template_item']['fields']);
  $missing_fields = [];
  foreach ($expected_fields as $field) {
    if (!$schema->fieldExists('pds_template_item', $field)) {
      $missing_fields[] = $field;
    }
  }

  $legacy_fields_present = FALSE;
  $legacy_fields = ['block_uuid', 'link', 'image_url', 'latitude', 'longitude'];
  foreach ($legacy_fields as $legacy_field) {
    if ($schema->fieldExists('pds_template_item', $legacy_field)) {
      $legacy_fields_present = TRUE;
      break;
    }
  }

  if (!$missing_fields && !$legacy_fields_present) {
    return;
  }

  $base_legacy_table = 'pds_template_item_legacy_9002';
  $legacy_table = $base_legacy_table;
  $suffix = 0;

  //5.- Pick a unique temporary table name so we never collide with earlier recovery attempts.
  while ($schema->tableExists($legacy_table)) {
    $suffix++;
    $legacy_table = $base_legacy_table . '_' . $suffix;
  }

  $schema->renameTable('pds_template_item', $legacy_table);
  $schema->createTable('pds_template_item', $schema_definition['pds_template_item']);

  $result = $connection->select($legacy_table, 'legacy')
    ->fields('legacy')
    ->execute();

  $time_service = \Drupal::time();
  $now = $time_service->getRequestTime();
  $uuid_service = \Drupal::service('uuid');

  foreach ($result as $record) {
    //6.- Skip empty rows early so corrupt legacy data never pollutes the rebuilt table.
    $header = trim((string) ($record->header ?? ''));
    if ($header === '') {
      continue;
    }

    $group_id = NULL;

    $block_uuid = isset($record->block_uuid) ? trim((string) $record->block_uuid) : '';
    if ($block_uuid !== '') {
      $group_id = \pds_recipe_template_ensure_group_and_get_id($block_uuid, 'pds_recipe_template');
    }
    elseif (isset($record->group_id) && is_numeric($record->group_id)) {
      $group_id = (int) $record->group_id;
    }

    if (!$group_id) {
      continue;
    }

    $stored_uuid = isset($record->uuid) ? (string) $record->uuid : '';
    if (!\Drupal\Component\Uuid\Uuid::isValid($stored_uuid)) {
      $stored_uuid = $uuid_service->generate();
    }

    $weight = isset($record->weight) && is_numeric($record->weight) ? (int) $record->weight : 0;
    $subheader = isset($record->subheader) ? (string) $record->subheader : '';
    $description = isset($record->description) ? (string) $record->description : '';

    $url = '';
    if (isset($record->url)) {
      $url = (string) $record->url;
    }
    elseif (isset($record->link)) {
      $url = (string) $record->link;
    }

    $desktop_img = '';
    if (isset($record->desktop_img)) {
      $desktop_img = (string) $record->desktop_img;
    }
    elseif (isset($record->image_url)) {
      $desktop_img = (string) $record->image_url;
    }

    $mobile_img = '';
    if (isset($record->mobile_img)) {
      $mobile_img = (string) $record->mobile_img;
    }
    elseif ($desktop_img !== '') {
      $mobile_img = $desktop_img;
    }

    $latitud = NULL;
    if (property_exists($record, 'latitud')) {
      $latitud = $record->latitud === NULL ? NULL : (float) $record->latitud;
    }
    elseif (property_exists($record, 'latitude')) {
      $latitud = $record->latitude === NULL ? NULL : (float) $record->latitude;
    }

    $longitud = NULL;
    if (property_exists($record, 'longitud')) {
      $longitud = $record->longitud === NULL ? NULL : (float) $record->longitud;
    }
    elseif (property_exists($record, 'longitude')) {
      $longitud = $record->longitude === NULL ? NULL : (float) $record->longitude;
    }

    $created_at = isset($record->created_at) && is_numeric($record->created_at) ? (int) $record->created_at : $now;

    try {
      //7.- Rebuild the row with the new schema so API calls no longer hit missing-column errors.
      $connection->insert('pds_template_item')
        ->fields([
          'uuid' => $stored_uuid,
          'group_id' => (int) $group_id,
          'weight' => $weight,
          'header' => $header,
          'subheader' => $subheader,
          'description' => $description,
          'url' => $url,
          'desktop_img' => $desktop_img,
          'mobile_img' => $mobile_img,
          'latitud' => $latitud,
          'longitud' => $longitud,
          'created_at' => $created_at,
          'deleted_at' => NULL,
        ])
        ->execute();
    }
    catch (\Throwable $throwable) {
      //8.- Ignore duplicate UUIDs or other insert errors so the migration keeps processing rows.
      continue;
    }
  }

  //9.- Drop the temporary table once every transferable row has been processed.
  $schema->dropTable($legacy_table);
}

/**
 * Force a clean rebuild of the recipe template tables.
 */
function pds_mxsuite_update_9024(): void {
  //1.- Load the canonical schema so recreated tables always match fresh installs.
  $schema_definition = _pds_mxsuite_get_table_definitions();
  $schema = \Drupal::database()->schema();

  //2.- Drop dependent tables first so stale structures never survive the rebuild.
  $tables_to_drop = ['pds_template_item_timeline', 'pds_template_item', 'pds_template_group'];
  foreach ($tables_to_drop as $table) {
    if ($schema->tableExists($table)) {
      $schema->dropTable($table);
    }
  }

  //3.- Recreate the group table before reintroducing the child item records.
  $schema->createTable('pds_template_group', $schema_definition['pds_template_group']);

  //4.- Recreate the item table so fresh rows can be inserted via the block UI again.
  $schema->createTable('pds_template_item', $schema_definition['pds_template_item']);

  //5.- Recreate the optional timeline table to keep dependent recipes working.
  $schema->createTable('pds_template_item_timeline', $schema_definition['pds_template_item_timeline']);
}

/**
 * Shared routine that performs a destructive rebuild of the template tables.
 */
function _pds_mxsuite_rebuild_template_tables(string $log_message): void {
  //1.- Drop dependent tables first so stale schema fragments never survive the rebuild.
  $schema = \Drupal::database()->schema();
  foreach (['pds_template_item_timeline', 'pds_template_item', 'pds_template_group'] as $table) {
    if ($schema->tableExists($table)) {
      $schema->dropTable($table);
    }
  }

  //2.- Recreate the tables from the canonical helper so new installs and updates stay aligned.
  _pds_mxsuite_create_tables();

  //3.- Log the rebuild outcome so operators can confirm the tables were recreated.
  \Drupal::logger('pds_mxsuite')->notice($log_message);
}
