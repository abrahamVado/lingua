<?php

use Drupal\Core\Logger\LoggerChannelInterface;
use Drupal\Core\Recipe\Recipe;
use Drupal\Core\Recipe\RecipeRunner;

/**
 * Implements hook_install().
 *
 * On fresh install of pds_mxsuite:
 * - Create DB tables needed by suite (group and item tables for template content).
 * - Run bundled recipes.
 */
function pds_mxsuite_install(): void {
  //1.- Ensure required tables exist on fresh install.
  _pds_mxsuite_create_tables();

  //2.- Apply bundled recipes so the suite ships with default content.
  $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
  $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
  $packages = _pds_mxsuite_get_recipe_packages();

  foreach ($packages as $module => $dir) {
    $path = $base . '/' . $dir;
    if (!is_dir($path)) {
      \Drupal::logger('pds_mxsuite')->warning(
        'Recipe directory missing for @module at @dir.',
        [
          '@module' => $module,
          '@dir' => $dir,
        ]
      );
      continue;
    }
    try {
      //3.- Execute each recipe to provision the expected demo configuration.
      $recipe = Recipe::createFromDirectory($path);
      RecipeRunner::processRecipe($recipe);
      \Drupal::logger('pds_mxsuite')->info('Recipe applied: @dir', ['@dir' => $dir]);
    }
    catch (\Throwable $e) {
      \Drupal::logger('pds_mxsuite')->error('Recipe @dir failed: @m', [
        '@dir' => $dir,
        '@m' => $e->getMessage(),
      ]);
    }
  }
}

/**
 * Implements hook_schema().
 */
function pds_mxsuite_schema(): array {
  //1.- Hand Drupal the canonical schema so core can manage installs and updates.
  $definitions = _pds_mxsuite_get_table_definitions();

  //2.- Return the subset keyed by table name to satisfy the hook contract.
  return [
    'pds_template_group' => $definitions['pds_template_group'],
    'pds_template_item' => $definitions['pds_template_item'],
  ];
}

/**
 * Shared helper.
 *
 * Creates the core tables:
 * - pds_template_group
 * - pds_template_item
 *
 * Safe to call multiple times. It will skip if tables already exist.
 */
function _pds_mxsuite_create_tables(): void {
  $schema = \Drupal::database()->schema();
  $definitions = _pds_mxsuite_get_table_definitions();

  // Master table = one component/group instance.
  if (!$schema->tableExists('pds_template_group')) {
    $schema->createTable('pds_template_group', $definitions['pds_template_group']);
  }

  // Child table = many cards per group.
  if (!$schema->tableExists('pds_template_item')) {
    $schema->createTable('pds_template_item', $definitions['pds_template_item']);
  }

}

/**
 * Build the canonical table definitions used across install-time helpers.
 */
function _pds_mxsuite_get_table_definitions(): array {
  //1.- Describe the group table exactly once so schema(), install(), and repairs share it.
  $group_definition = [
    'description' => 'Logical group of template items (one rendered component instance).',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'type' => [
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        // e.g. "pds_recipe_executives"
        //      "pds_recipe_formas_de_invertir"
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'type' => ['type'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //2.- Mirror the runtime expectations for items so every code path provisions the same schema.
  $item_definition = [
    'description' => 'Items/cards that belong to a template group.',
    'fields' => [
      'id' => [
        'type' => 'serial',
        'not null' => TRUE,
      ],
      'uuid' => [
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ],
      'group_id' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        // FK to pds_template_group.id
      ],
      'weight' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'header' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'subheader' => [
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ],
      'description' => [
        'type' => 'text',
        'size' => 'big',
        'not null' => FALSE,
      ],
      'url' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'desktop_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'mobile_img' => [
        'type' => 'varchar',
        'length' => 512,
        'not null' => TRUE,
        'default' => '',
      ],
      'latitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'longitud' => [
        'type' => 'float',
        'not null' => FALSE,
      ],
      'created_at' => [
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ],
      'deleted_at' => [
        'type' => 'int',
        'not null' => FALSE,
      ],
    ],
    'primary key' => ['id'],
    'unique keys' => [
      'uuid' => ['uuid'],
    ],
    'indexes' => [
      'group_id' => ['group_id'],
      'weight' => ['weight'],
      'deleted_at' => ['deleted_at'],
    ],
  ];

  //3.- Cache the definitions in memory for the current request so repeated calls stay cheap.
  return [
    'pds_template_group' => $group_definition,
    'pds_template_item' => $item_definition,
  ];
}

/**
 * Include the schema repairer class when the container cannot autoload it.
 */
function _pds_mxsuite_include_schema_repairer(?LoggerChannelInterface $logger = NULL): bool {
  //1.- Delegate to the shared helper when it exists so both modules stay aligned.
  if (function_exists('pds_recipe_template_include_service_class')) {
    if (pds_recipe_template_include_service_class('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer', '/src/Service/LegacySchemaRepairer.php')) {
      return TRUE;
    }
  }

  //2.- Skip the include work when the class is already present in memory.
  if (class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer')) {
    return TRUE;
  }

  try {
    //3.- Look up the module path dynamically so multisite installs remain compatible.
    if (\Drupal::hasService('extension.list.module')) {
      $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_template');
      if (is_string($module_path) && $module_path !== '') {
        $legacy_repairer_path = DRUPAL_ROOT . '/' . $module_path . '/src/Service/LegacySchemaRepairer.php';
        if (is_readable($legacy_repairer_path)) {
          require_once $legacy_repairer_path;
        }
      }
    }
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to include schema repairer class manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //4.- Report whether the class could be loaded so callers can attempt manual instantiation.
  return class_exists('\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer');
}

/**
 * Build the schema repairer without the service container when necessary.
 */
function _pds_mxsuite_build_schema_repairer(?LoggerChannelInterface $logger = NULL): ?object {
  //1.- Ensure the class definition is available before attempting instantiation.
  if (!_pds_mxsuite_include_schema_repairer($logger)) {
    return NULL;
  }

  try {
    //2.- Construct the repairer directly so update hooks can run during cache rebuilds.
    return new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
      \Drupal::database(),
      \Drupal::service('datetime.time'),
      \Drupal::service('uuid'),
      \Drupal::service('logger.factory')
    );
  }
  catch (\Throwable $throwable) {
    if ($logger) {
      $logger->error('Unable to instantiate schema repairer manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
    return NULL;
  }
}

/**
 * Cleanup dup config and re-run recipes.
 *
 * This is your existing update 8013.
 */
function pds_mxsuite_update_8013(): void {
  $dups = ['pds_recipe_fondos_mutuos.settings']; // la que choca
  foreach ($dups as $name) {
    $conf = \Drupal::config($name);
    if (!$conf->isNew()) {
      \Drupal::logger('pds_mxsuite')->warning(
        'Deleting existing config @c to prevent collision.',
        ['@c' => $name]
      );
      \Drupal::configFactory()->getEditable($name)->delete();
    }
  }

  // Reapply recipes or install modules depending on platform.
  if (class_exists('\Drupal\Core\Recipe\Recipe')) {
    $module_path = \Drupal::service('extension.list.module')->getPath('pds_mxsuite');
    $base = DRUPAL_ROOT . '/' . $module_path . '/recipes';
    foreach (_pds_mxsuite_get_recipe_packages() as $module => $dir) {
      $path = $base . '/' . $dir;
      if (is_dir($path)) {
        $r = \Drupal\Core\Recipe\Recipe::createFromDirectory($path);
        \Drupal\Core\Recipe\RecipeRunner::processRecipe($r);
      }
    }
  }
  else {
    \Drupal::service('module_installer')->install(array_keys(_pds_mxsuite_get_recipe_packages()), TRUE);
  }
}

/**
 * Provide a canonical list of recipe modules and their directories.
 */
function _pds_mxsuite_get_recipe_packages(): array {
  //1.- Keep module names and recipe directories aligned in a single source of truth.
  return [
    'pds_recipe_fondos_mutuos' => 'fondos_mutuos',
    'pds_recipe_educacion_financiera' => 'educacion_financiera',
    'pds_recipe_formas_de_invertir' => 'formas_de_invertir',
    'pds_recipe_mapa' => 'mapa',
    'pds_recipe_executives' => 'executives',
    'pds_recipe_slider_banner' => 'slider_banner',
    'pds_recipe_template' => 'template',
  ];
}

/**
 * New update hook to backfill the tables on sites where pds_mxsuite
 * is already enabled and running.
 *
 * This will run once when you deploy this code
 * and execute `drush updb` or load /update.php.
 */
function pds_mxsuite_update_9010(): void {
  _pds_mxsuite_create_tables();

  \Drupal::logger('pds_mxsuite')->notice(
    'Ensured template tables (group, item) exist.'
  );
}

/**
 * Ensure legacy template tables are upgraded to the new schema.
 */
function pds_mxsuite_update_9012(): void {
  //1.- Create missing tables first so the schema repairer can safely rebuild them.
  _pds_mxsuite_create_tables();

  $logger = \Drupal::logger('pds_mxsuite');
  $repairer = NULL;

  //2.- Reuse the container-managed repairer when the module is enabled.
  if (\Drupal::hasService('pds_recipe_template.legacy_schema_repairer')) {
    if (!_pds_mxsuite_include_schema_repairer($logger)) {
      $logger->error('Unable to load schema repairer class via the service container.');
    }
    try {
      //3.- Defer to the registered service so shared state remains consistent.
      $repairer = \Drupal::service('pds_recipe_template.legacy_schema_repairer');
    }
    catch (\Throwable $throwable) {
      $logger->error('Unable to load schema repairer service during update 9012: @message', [
        '@message' => $throwable->getMessage(),
      ]);
      $repairer = NULL;
    }
  }

  //4.- Fall back to a manual instance when the service is unavailable or failed.
  if (!$repairer) {
    $repairer = _pds_mxsuite_build_schema_repairer($logger);
  }

  if ($repairer) {
    //5.- Stop early when the repairer reports success so the deployment log highlights the completed check.
    if ($repairer->ensureItemTableUpToDate()) {
      $logger->notice(
        'Verified pds_template_item schema after installing the consolidated update.'
      );
      return;
    }

    //6.- Warn administrators when the rebuild fails so they can inspect dblog for details.
    $logger->warning(
      'Unable to refresh the pds_template_item schema automatically. Check recent log messages for the exact cause.'
    );
    return;
  }

  //7.- Flag the absence of the repairer so site owners know manual intervention is required.
  $logger->warning(
    'The pds_recipe_template schema repairer is unavailable. Manually review the pds_template_item table for legacy columns such as link or image_url.'
  );
}

/**
 * Force a clean rebuild of the recipe template tables.
 */
function pds_mxsuite_update_9015(): void {
  //1.- Delegate to the shared rebuild helper so future updates can reuse the routine.
  _pds_mxsuite_rebuild_template_tables('Rebuilt template tables (group, item) via update 9015.');
}

/**
 * Drop and recreate the template tables to guarantee a clean schema.
 */
function pds_mxsuite_update_9020(): void {
  //1.- Reuse the rebuild helper so update.php can refresh the tables during this deployment.
  _pds_mxsuite_rebuild_template_tables('Rebuilt template tables (group, item) via update 9020.');
}

/**
 * Shared routine that performs a destructive rebuild of the template tables.
 */
function _pds_mxsuite_rebuild_template_tables(string $log_message): void {
  //1.- Drop dependent tables first so stale schema fragments never survive the rebuild.
  $schema = \Drupal::database()->schema();
  foreach (['pds_template_item', 'pds_template_group'] as $table) {
    if ($schema->tableExists($table)) {
      $schema->dropTable($table);
    }
  }

  //2.- Recreate the tables from the canonical helper so new installs and updates stay aligned.
  _pds_mxsuite_create_tables();

  //3.- Log the rebuild outcome so operators can confirm the tables were recreated.
  \Drupal::logger('pds_mxsuite')->notice($log_message);
}
