<?php

/**
 * @file
 * Hooks for pds_recipe_template.
 */

/**
 * Implements hook_theme().
 *
 * Registers the theme hook `pds_template_block`.
 * Maps it to templates/pds-template-block.html.twig.
 */
function pds_recipe_template_theme($existing, $type, $theme, $path) {
  return [
    'pds_template_block' => [
      'template' => 'pds-template', // looks for pds-template-block.html.twig
      'path' => $path . '/templates',
      'variables' => [
        'items' => [],
        'group_id' => NULL,
        'instance_uuid' => '',
      ],
    ],
  ];
}

if (!function_exists('pds_recipe_template_get_logger')) {
  /**
   * Provide a logger instance without assuming the container is ready.
   */
  function pds_recipe_template_get_logger(): ?\Drupal\Core\Logger\LoggerChannelInterface {
    static $logger;
    static $initialized = FALSE;

    //1.- Avoid repeated lookups so repeated helper calls stay efficient.
    if ($initialized) {
      return $logger;
    }

    $initialized = TRUE;

    try {
      //2.- Ask Drupal for the module channel when the logger factory service exists.
      if (method_exists('\Drupal', 'logger')) {
        $logger = \Drupal::logger('pds_recipe_template');
      }
    }
    catch (\Throwable $throwable) {
      //3.- Suppress bootstrap errors because fallback logic should never fatally fail.
      $logger = NULL;
    }

    return $logger;
  }
}

if (!function_exists('pds_recipe_template_include_service_class')) {
  /**
   * Attempt to include a service class when the autoloader cannot find it.
   */
  function pds_recipe_template_include_service_class(string $class, string $relative_path): bool {
    //1.- Skip all work when the caller already loaded the class in this request.
    if (class_exists($class, FALSE)) {
      return TRUE;
    }

    $logger = pds_recipe_template_get_logger();

    //2.- Look inside the module directory directly so cache rebuilds keep working.
    $paths = [__DIR__ . $relative_path];

    //3.- Resolve the module path from the extension list when the container is ready.
    if (defined('DRUPAL_ROOT') && method_exists('\Drupal', 'hasService') && \Drupal::hasService('extension.list.module')) {
      try {
        $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_template');
        if (is_string($module_path) && $module_path !== '') {
          $paths[] = DRUPAL_ROOT . '/' . $module_path . $relative_path;
        }
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve module path while including @class: @message', [
            '@class' => $class,
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //4.- Attempt each candidate path until the class definition is available.
    foreach ($paths as $path) {
      if (!is_string($path) || $path === '') {
        continue;
      }
      if (!is_readable($path)) {
        continue;
      }

      try {
        require_once $path;
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to include @class from @path: @message', [
            '@class' => $class,
            '@path' => $path,
            '@message' => $throwable->getMessage(),
          ]);
        }
        continue;
      }

      if (class_exists($class, FALSE)) {
        return TRUE;
      }
    }

    //5.- Report whether the helper managed to load the class so callers can fallback.
    return class_exists($class, FALSE);
  }
}

if (!function_exists('pds_recipe_template_try_service')) {
  /**
   * Safely fetch a service from the container when possible.
   */
  function pds_recipe_template_try_service(string $service_id, ?string $log_message = NULL, array $context = []): ?object {
    //1.- Ensure the static container exists and knows about the requested service.
    if (!method_exists('\Drupal', 'hasService') || !\Drupal::hasService($service_id)) {
      return NULL;
    }

    try {
      //2.- Delegate to the container once it can provide the dependency.
      return \Drupal::service($service_id);
    }
    catch (\Throwable $throwable) {
      //3.- Emit the provided message so logs capture the root cause for administrators.
      if ($log_message) {
        $logger = pds_recipe_template_get_logger();
        if ($logger) {
          $context['@service'] = $service_id;
          $context['@message'] = $throwable->getMessage();
          $logger->error($log_message, $context);
        }
      }
      return NULL;
    }
  }
}

if (!function_exists('pds_recipe_template_ensure_group_and_get_id')) {
  /**
   * Ensure a template group exists for the provided UUID and return its id.
   */
  function pds_recipe_template_ensure_group_and_get_id(string $uuid, string $type = 'pds_recipe_template'): ?int {
    //1.- Reject empty UUIDs immediately so no database work happens without an identifier.
    if ($uuid === '') {
      return NULL;
    }

    $normalized_type = $type !== '' ? $type : 'pds_recipe_template';

    try {
      //2.- Attempt to reuse an existing active group row for this UUID.
      $connection = \Drupal::database();
      $existing_id = $connection->select('pds_template_group', 'g')
        ->fields('g', ['id'])
        ->condition('g.uuid', $uuid)
        ->condition('g.deleted_at', NULL, 'IS NULL')
        ->execute()
        ->fetchField();

      if ($existing_id) {
        return (int) $existing_id;
      }

      $now = \Drupal::time()->getRequestTime();

      try {
        //3.- Insert a fresh group row when the UUID has never been persisted before.
        $connection->insert('pds_template_group')
          ->fields([
            'uuid' => $uuid,
            'type' => $normalized_type,
            'created_at' => $now,
            'deleted_at' => NULL,
          ])
          ->execute();
      }
      catch (\Throwable $insert_exception) {
        //4.- Ignore duplicate key races because concurrent requests may create it too.
      }

      //5.- Resolve the identifier again to cover both inserts and duplicates gracefully.
      $new_id = $connection->select('pds_template_group', 'g')
        ->fields('g', ['id'])
        ->condition('g.uuid', $uuid)
        ->condition('g.deleted_at', NULL, 'IS NULL')
        ->execute()
        ->fetchField();

      return $new_id ? (int) $new_id : NULL;
    }
    catch (\Throwable $exception) {
      //6.- Fail softly so callers can fall back to configuration snapshots when DB errors appear.
      return NULL;
    }
  }
}

if (!function_exists('pds_recipe_template_resolve_row_image_promoter')) {
  /**
   * Resolve the row image promoter service even when the container is rebuilding.
   */
  function pds_recipe_template_resolve_row_image_promoter(): ?object {
    $promoter_class = '\\Drupal\\pds_recipe_template\\Service\\RowImagePromoter';

    $logger = pds_recipe_template_get_logger();

    //1.- Ensure the class definition exists before touching the service container.
    if (!pds_recipe_template_include_service_class($promoter_class, '/src/Service/RowImagePromoter.php')) {
      if ($logger) {
        $logger->error('Unable to locate row image promoter class.');
      }
      return NULL;
    }

    //2.- Prefer the container-managed service so dependency injection remains the primary path.
    if (method_exists('\Drupal', 'hasService') && \Drupal::hasService('pds_recipe_template.row_image_promoter')) {
      try {
        return \Drupal::service('pds_recipe_template.row_image_promoter');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to load row image promoter service: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //3.- Resolve required dependencies individually so cache rebuilds can still promote uploads.
    $entity_type_manager = pds_recipe_template_try_service(
      'entity_type.manager',
      'Unable to load @service while instantiating row image promoter: @message'
    );
    $file_url_generator = pds_recipe_template_try_service(
      'file_url_generator',
      'Unable to load @service while instantiating row image promoter: @message'
    );

    if (!$entity_type_manager || !$file_url_generator) {
      if ($logger) {
        $logger->error('Unable to build row image promoter manually because required services are missing.');
      }
      return NULL;
    }

    try {
      //4.- Instantiate the promoter directly when the container cannot provide it yet.
      return new \Drupal\pds_recipe_template\Service\RowImagePromoter(
        $entity_type_manager,
        $file_url_generator
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to instantiate row image promoter: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
    }

    //5.- Return NULL so callers can emit a helpful error response to editors.
    return NULL;
  }
}

if (!function_exists('pds_recipe_template_resolve_schema_repairer')) {
  /**
   * Resolve the schema repairer even when the service container is rebuilding.
   */
  function pds_recipe_template_resolve_schema_repairer(): ?object {
    $repairer_class = '\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer';

    $logger = pds_recipe_template_get_logger();

    //1.- Load the class manually when the autoloader cannot find it yet.
    if (!pds_recipe_template_include_service_class($repairer_class, '/src/Service/LegacySchemaRepairer.php')) {
      if ($logger) {
        $logger->error('Unable to locate schema repairer class.');
      }
      return NULL;
    }

    //2.- Prefer the registered service so requests benefit from shared state and caching.
    if (method_exists('\Drupal', 'hasService') && \Drupal::hasService('pds_recipe_template.legacy_schema_repairer')) {
      try {
        return \Drupal::service('pds_recipe_template.legacy_schema_repairer');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to load schema repairer service: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //3.- Capture the dependencies individually so cache rebuilds can still repair tables.
    $time_service = pds_recipe_template_try_service(
      'datetime.time',
      'Unable to load @service while instantiating schema repairer: @message'
    );
    $uuid_service = pds_recipe_template_try_service(
      'uuid',
      'Unable to load @service while instantiating schema repairer: @message'
    );
    $logger_factory = pds_recipe_template_try_service(
      'logger.factory',
      'Unable to load @service while instantiating schema repairer: @message'
    );

    if (!$time_service || !$uuid_service || !$logger_factory) {
      if ($logger) {
        $logger->error('Unable to build schema repairer manually because required services are missing.');
      }
      return NULL;
    }

    try {
      //4.- Instantiate the repairer directly to cover requests during container rebuilds.
      return new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
        \Drupal::database(),
        $time_service,
        $uuid_service,
        $logger_factory
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to instantiate schema repairer manually: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
    }

    //5.- Return NULL when both the service container and manual instantiation fail.
    return NULL;
  }
}
