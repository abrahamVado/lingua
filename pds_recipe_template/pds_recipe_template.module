<?php

/**
 * @file
 * Hooks for pds_recipe_template.
 */

/**
 * Implements hook_theme().
 *
 * Registers the theme hook `pds_template_block`.
 * Maps it to templates/pds-template-block.html.twig.
 */
function pds_recipe_template_theme($existing, $type, $theme, $path) {
  return [
    'pds_template_block' => [
      'template' => 'pds-template', // looks for pds-template-block.html.twig
      'path' => $path . '/templates',
      'variables' => [
        'items' => [],
        'group_id' => NULL,
        'instance_uuid' => '',
      ],
    ],
  ];
}

/**
 * Ensure a template group exists for the provided UUID and return its id.
 */
function pds_recipe_template_ensure_group_and_get_id(string $uuid, string $type = 'pds_recipe_template'): ?int {
  //1.- Reject empty UUIDs immediately so no database work happens without an identifier.
  if ($uuid === '') {
    return NULL;
  }

  $normalized_type = $type !== '' ? $type : 'pds_recipe_template';

  try {
    //2.- Attempt to reuse an existing active group row for this UUID.
    $connection = \Drupal::database();
    $existing_id = $connection->select('pds_template_group', 'g')
      ->fields('g', ['id'])
      ->condition('g.uuid', $uuid)
      ->condition('g.deleted_at', NULL, 'IS NULL')
      ->execute()
      ->fetchField();

    if ($existing_id) {
      return (int) $existing_id;
    }

    $now = \Drupal::time()->getRequestTime();

    try {
      //3.- Insert a fresh group row when the UUID has never been persisted before.
      $connection->insert('pds_template_group')
        ->fields([
          'uuid' => $uuid,
          'type' => $normalized_type,
          'created_at' => $now,
          'deleted_at' => NULL,
        ])
        ->execute();
    }
    catch (\Throwable $insert_exception) {
      //4.- Ignore duplicate key races because concurrent requests may create it too.
    }

    //5.- Resolve the identifier again to cover both inserts and duplicates gracefully.
    $new_id = $connection->select('pds_template_group', 'g')
      ->fields('g', ['id'])
      ->condition('g.uuid', $uuid)
      ->condition('g.deleted_at', NULL, 'IS NULL')
      ->execute()
      ->fetchField();

    return $new_id ? (int) $new_id : NULL;
  }
  catch (\Throwable $exception) {
    //6.- Fail softly so callers can fall back to configuration snapshots when DB errors appear.
    return NULL;
  }
}

/**
 * Resolve the row image promoter service even when the container is rebuilding.
 */
function pds_recipe_template_resolve_row_image_promoter(): ?object {
  $promoter_class = '\\Drupal\\pds_recipe_template\\Service\\RowImagePromoter';

  //1.- Attempt to reuse the registered service so dependency injection remains the default path.
  if (\Drupal::hasService('pds_recipe_template.row_image_promoter')) {
    try {
      return \Drupal::service('pds_recipe_template.row_image_promoter');
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to load row image promoter service: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //2.- Include the class manually with a direct path so we avoid relying on other services mid-rebuild.
  if (!class_exists($promoter_class, FALSE)) {
    try {
      $promoter_path = __DIR__ . '/src/Service/RowImagePromoter.php';
      if (is_readable($promoter_path)) {
        require_once $promoter_path;
      }
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to include row image promoter class manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //3.- Build the promoter on demand when the dependency injection container is unavailable.
  if (class_exists($promoter_class, FALSE)) {
    try {
      return new \Drupal\pds_recipe_template\Service\RowImagePromoter(
        \Drupal::service('entity_type.manager'),
        \Drupal::service('file_url_generator')
      );
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to instantiate row image promoter: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //4.- Return NULL so callers can emit a helpful error response to editors.
  return NULL;
}
/**
 * Resolve the schema repairer even when the service container is rebuilding.
 */
function pds_recipe_template_resolve_schema_repairer(): ?object {
  $repairer_class = '\\Drupal\\pds_recipe_template\\Service\\LegacySchemaRepairer';

  //1.- Attempt to include the class definition manually when the autoloader misses it.
  if (!class_exists($repairer_class, FALSE)) {
    try {
      $repairer_path = __DIR__ . '/src/Service/LegacySchemaRepairer.php';
      if (is_readable($repairer_path)) {
        require_once $repairer_path;
      }
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to include schema repairer class manually: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //2.- Reuse the registered service when the dependency injection container is ready.
  if (class_exists($repairer_class, FALSE) && \Drupal::hasService('pds_recipe_template.legacy_schema_repairer')) {
    try {
      return \Drupal::service('pds_recipe_template.legacy_schema_repairer');
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to load schema repairer service: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //3.- Retry the manual include once more when the service container failed to bootstrap the class.
  if (!class_exists($repairer_class, FALSE)) {
    try {
      $repairer_path = __DIR__ . '/src/Service/LegacySchemaRepairer.php';
      if (is_readable($repairer_path)) {
        require_once $repairer_path;
      }
    }
    catch (\Throwable $throwable) {
      \Drupal::logger('pds_recipe_template')->error('Unable to include schema repairer class on retry: @message', [
        '@message' => $throwable->getMessage(),
      ]);
    }
  }

  //4.- Abort when the class cannot be located so callers can surface a clear error message.
  if (!class_exists($repairer_class, FALSE)) {
    return NULL;
  }

  //5.- Instantiate the repairer directly to support requests running during cache rebuilds.
  try {
    return new \Drupal\pds_recipe_template\Service\LegacySchemaRepairer(
      \Drupal::database(),
      \Drupal::service('datetime.time'),
      \Drupal::service('uuid'),
      \Drupal::service('logger.factory')
    );
  }
  catch (\Throwable $throwable) {
    \Drupal::logger('pds_recipe_template')->error('Unable to instantiate schema repairer manually: @message', [
      '@message' => $throwable->getMessage(),
    ]);
  }

  //6.- Return NULL when both the service container and manual instantiation fail.
  return NULL;
}
