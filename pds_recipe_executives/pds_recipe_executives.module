<?php

use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_theme().
 *
 * Exposes the twig template "pds-executives.html.twig" as theme hook "pds_executives".
 * Declares variable "executives" so Twig can loop.
 */
function pds_recipe_executives_theme($existing, $type, $theme, $path) {
  return [
    'pds_executives' => [
      'template' => 'pds-executives', // templates/pds-executives.html.twig
      'path' => $path . '/templates',
      'variables' => [
        'executives' => [],
      ],
    ],
  ];
}

/**
 * AJAX callback to return just the executives_ui container.
 * Works for both normal block config and Layout Builder modal.
 */
function pds_recipe_executives_ajax_execs(array &$form, FormStateInterface $form_state) {
  if (isset($form['settings']['executives_ui'])) {
    return $form['settings']['executives_ui'];
  }
  if (isset($form['executives_ui'])) {
    return $form['executives_ui'];
  }
  return $form;
}

/**
 * "Add executive" submit handler.
 *
 * Steps:
 * 1. Read the current rows from form_state.
 *    If empty (common first-click in Layout Builder) then fall back to
 *    $form_state->get('working_execs') which was seeded in blockForm().
 * 2. Append a blank row.
 * 3. Save back into form_state values and into working_execs.
 * 4. setRebuild(TRUE) so AJAX redraws the table with the new row.
 */
function pds_recipe_executives_add_exec_submit(array &$form, FormStateInterface $form_state): void {
  // Detect Layout Builder vs normal block edit.
  if (isset($form['settings'])) {
    $base_key = ['settings', 'executives_ui', 'execs'];
  }
  else {
    $base_key = ['executives_ui', 'execs'];
  }

  // Attempt to pull current table rows.
  $execs = $form_state->getValue($base_key);
  if (!is_array($execs) || $execs === []) {
    // Fallback to working_execs snapshot that blockForm() seeded.
    $snapshot = $form_state->get('working_execs');
    if (is_array($snapshot)) {
      $execs = $snapshot;
    }
    else {
      $execs = [];
    }
  }

  // Append blank row.
  $execs[] = [
    'fid'      => [],
    'name'     => '',
    'title'    => '',
    'linkedin' => '',
    'cv_html'  => '',
    'remove'   => 0,
  ];

  // Write updated rows back into form_state's values so Drupal rebuild
  // knows there are N+1 rows now.
  $form_state->setValue($base_key, $execs);

  // Keep same list in working_execs so getWorkingExecs() sees it even
  // in Layout Builder SubformState contexts.
  $form_state->set('working_execs', $execs);

  // Force rebuild so AJAX callback returns updated markup.
  $form_state->setRebuild(TRUE);
}

/**
 * "Remove selected" submit handler.
 *
 * Steps:
 * 1. Read current rows from form_state or fallback to working_execs.
 * 2. Filter out rows where 'remove' is checked.
 * 3. Save filtered list back into values and working_execs.
 * 4. setRebuild(TRUE) for AJAX redraw.
 */
function pds_recipe_executives_remove_selected_submit(array &$form, FormStateInterface $form_state): void {
  if (isset($form['settings'])) {
    $base_key = ['settings', 'executives_ui', 'execs'];
  }
  else {
    $base_key = ['executives_ui', 'execs'];
  }

  $execs = $form_state->getValue($base_key);
  if (!is_array($execs) || $execs === []) {
    $snapshot = $form_state->get('working_execs');
    if (is_array($snapshot)) {
      $execs = $snapshot;
    }
    else {
      $execs = [];
    }
  }

  // Keep rows without the 'remove' flag.
  $execs = array_values(array_filter($execs, static function ($row) {
    return is_array($row) && empty($row['remove']);
  }));

  // Sync back to form_state values.
  $form_state->setValue($base_key, $execs);

  // Sync to working_execs so blockForm() will re-render same list.
  $form_state->set('working_execs', $execs);

  // Trigger rebuild so AJAX replaces the container with updated table.
  $form_state->setRebuild(TRUE);
}
