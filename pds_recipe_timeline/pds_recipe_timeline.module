<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Form\SubformStateInterface;

/**
 * Implements hook_theme().
 *
 * Exposes the twig template "pds-timeline.html.twig" as theme hook "pds_timeline".
 * Declares variable "events" so Twig can loop.
 */
function pds_recipe_timeline_theme($existing, $type, $theme, $path) {
  return [
    'pds_timeline' => [
      'template' => 'pds-timeline', // templates/pds-timeline.html.twig
      'path' => $path . '/templates',
      'variables' => [
        'title' => '',
        'years' => [],
        'rows' => [],
        'timeline_id' => 'principal-timeline',
      ],
    ],
  ];
}

/**
 * AJAX callback to return just the timeline_ui container.
 * Works for both normal block config and Layout Builder modal.
 */
function pds_recipe_timeline_ajax_events(array &$form, FormStateInterface $form_state) {
  if (isset($form['settings']['timeline_ui'])) {
    return $form['settings']['timeline_ui'];
  }
  if (isset($form['timeline_ui'])) {
    return $form['timeline_ui'];
  }
  return $form;
}

/**
 * "Add person" submit handler.
 */
function pds_recipe_timeline_add_person_submit(array &$form, FormStateInterface $form_state): void {
  //1.- Determine the correct root path regardless of Layout Builder or direct edit.
  $trigger = $form_state->getTriggeringElement();
  $parents = is_array($trigger['#parents'] ?? NULL) ? $trigger['#parents'] : [];
  $base_key = in_array('settings', $parents, TRUE) || isset($form['settings'])
    ? ['settings', 'timeline_ui', 'add_person']
    : ['timeline_ui', 'add_person'];

  //2.- Gain access to the parent form state when operating inside a subform context.
  $parent_state = NULL;
  if ($form_state instanceof SubformStateInterface && method_exists($form_state, 'getCompleteFormState')) {
    $parent_state = $form_state->getCompleteFormState();
  }

  //3.- Retrieve sanitized information prepared by the validation handler.
  $new_person = $form_state->get('pds_recipe_timeline_add_person_new_person');
  if (!is_array($new_person) || ($new_person['milestones'] ?? []) === []) {
    return;
  }

  //4.- Append the new person to the working list stored in form state.
  $people = $form_state->get('working_people');
  if (!is_array($people)) {
    $people = [];
  }

  $people[] = $new_person;

  //5.- Sync the working snapshot across the current and parent form states.
  $normalized_people = array_values($people);
  $form_state->set('working_people', $normalized_people);
  if ($parent_state) {
    $parent_state->set('working_people', $normalized_people);
  }

  //6.- Reset author-facing inputs so the form is ready for the next addition.
  $form_state->setValue(array_merge($base_key, ['person_name']), '');
  $form_state->setValue(array_merge($base_key, ['person_role']), '');
  $form_state->setValue(array_merge($base_key, ['milestones_json']), '');
  if ($parent_state) {
    $parent_state->setValue(array_merge($base_key, ['person_name']), '');
    $parent_state->setValue(array_merge($base_key, ['person_role']), '');
    $parent_state->setValue(array_merge($base_key, ['milestones_json']), '');
  }

  //7.- Keep checkbox submissions aligned with the refreshed list of people.
  $table_key = in_array('settings', $parents, TRUE) || isset($form['settings'])
    ? ['settings', 'timeline_ui', 'people_list', 'people']
    : ['timeline_ui', 'people_list', 'people'];
  $checkbox_rows = [];
  foreach ($normalized_people as $index => $_row) {
    $checkbox_rows[$index] = ['remove' => 0];
  }
  $form_state->setValue($table_key, $checkbox_rows);
  if ($parent_state) {
    $parent_state->setValue($table_key, $checkbox_rows);
  }

  //8.- Clear the temporary storage and force a rebuild to refresh the UI.
  $form_state->set('pds_recipe_timeline_add_person_new_person', NULL);
  $form_state->setRebuild(TRUE);
}

/**
 * "Remove selected" submit handler for the people table.
 */
function pds_recipe_timeline_remove_people_submit(array &$form, FormStateInterface $form_state): void {
  //1.- Figure out where the table values live by inspecting the triggering element.
  $trigger = $form_state->getTriggeringElement();
  $parents = is_array($trigger['#parents'] ?? NULL) ? $trigger['#parents'] : [];
  $table_key = in_array('settings', $parents, TRUE) || isset($form['settings'])
    ? ['settings', 'timeline_ui', 'people_list', 'people']
    : ['timeline_ui', 'people_list', 'people'];

  //2.- Obtain the parent form state when operating inside Layout Builder subforms.
  $parent_state = NULL;
  if ($form_state instanceof SubformStateInterface && method_exists($form_state, 'getCompleteFormState')) {
    $parent_state = $form_state->getCompleteFormState();
  }

  //3.- Collect the working snapshot that stores the actual person data.
  $people = $form_state->get('working_people');
  if (!is_array($people)) {
    $people = [];
  }

  //4.- Read checkbox submissions from either the current or parent form state.
  $values = $form_state->getValue($table_key);
  if (!is_array($values) && $parent_state) {
    $values = $parent_state->getValue($table_key);
  }
  if (!is_array($values)) {
    $values = [];
  }

  //5.- Remove any person whose checkbox was selected.
  foreach ($values as $delta => $row) {
    if (!empty($row['remove']) && isset($people[$delta])) {
      unset($people[$delta]);
    }
  }

  //6.- Save filtered results back to the form state hierarchy for subsequent rebuilds.
  $normalized_people = array_values($people);
  $form_state->set('working_people', $normalized_people);
  if ($parent_state) {
    $parent_state->set('working_people', $normalized_people);
  }

  //7.- Reset checkbox submissions so future clicks start from a clean state.
  $fresh_values = [];
  foreach ($normalized_people as $index => $_row) {
    $fresh_values[$index] = ['remove' => 0];
  }
  $form_state->setValue($table_key, $fresh_values);
  if ($parent_state) {
    $parent_state->setValue($table_key, $fresh_values);
  }

  //8.- Ask Drupal to rebuild the form to reflect the removal immediately.
  $form_state->setRebuild(TRUE);
}

/**
 * "Add person" validation handler.
 */
function pds_recipe_timeline_add_person_validate(array &$form, FormStateInterface $form_state): void {
  //1.- Choose the correct keys according to the editing context.
  $base_key = isset($form['settings']) ? ['settings', 'timeline_ui', 'add_person'] : ['timeline_ui', 'add_person'];

  //2.- Gather author entered values from the UI.
  $name = trim((string) $form_state->getValue(array_merge($base_key, ['person_name'])));
  $role = trim((string) $form_state->getValue(array_merge($base_key, ['person_role'])));
  $milestones_json = trim((string) $form_state->getValue(array_merge($base_key, ['milestones_json'])));

  if ($milestones_json === '') {
    $form_state->setErrorByName('timeline_ui][add_person][milestones_json', t('Milestones JSON is required to create a person.'));
    return;
  }

  //3.- Attempt to decode and normalize the JSON payload.
  $decoded = json_decode($milestones_json, TRUE);
  if (!is_array($decoded)) {
    $form_state->setErrorByName('timeline_ui][add_person][milestones_json', t('The milestones must be valid JSON.'));
    return;
  }

  $milestones = [];

  if (pds_recipe_timeline_is_list($decoded)) {
    foreach ($decoded as $item) {
      if (!is_array($item)) {
        continue;
      }

      $year = trim((string) ($item['year'] ?? ''));
      $text = trim((string) ($item['text'] ?? ''));
      $info = trim((string) ($item['info'] ?? ''));
      $info_html = trim((string) ($item['info_html'] ?? ''));
      $width = pds_recipe_timeline_parse_numeric($item['width'] ?? ($item['width_percent'] ?? $item['width_pct'] ?? NULL));
      $principal = array_key_exists('principal', $item)
        ? pds_recipe_timeline_cast_bool($item['principal'])
        : (isset($item['type']) && strtolower((string) $item['type']) === 'principal');
      $first = array_key_exists('first', $item)
        ? pds_recipe_timeline_cast_bool($item['first'])
        : (array_key_exists('is_first', $item) ? pds_recipe_timeline_cast_bool($item['is_first']) : FALSE);
      $img_src = trim((string) ($item['img_src'] ?? $item['image'] ?? ''));
      $img_alt = trim((string) ($item['img_alt'] ?? $item['image_alt'] ?? ''));

      if ($year === '' && $text === '' && $info === '' && $info_html === '' && $img_src === '' && $img_alt === '' && $width === NULL && !$principal && !$first) {
        continue;
      }

      $entry = [];
      if ($year !== '') {
        $entry['year'] = $year;
      }
      if ($text !== '') {
        $entry['text'] = $text;
      }
      if ($info !== '') {
        $entry['info'] = $info;
      }
      if ($info_html !== '') {
        $entry['info_html'] = $info_html;
      }
      if ($width !== NULL && $width > 0) {
        $entry['width'] = $width;
      }
      if ($principal) {
        $entry['principal'] = TRUE;
      }
      if ($first) {
        $entry['first'] = TRUE;
      }
      if ($img_src !== '') {
        $entry['img_src'] = $img_src;
      }
      if ($img_alt !== '') {
        $entry['img_alt'] = $img_alt;
      }

      if ($entry !== []) {
        $milestones[] = $entry;
      }
    }
  }
  else {
    foreach ($decoded as $year => $text) {
      $year_str = trim((string) $year);
      $text_str = trim((string) $text);
      if ($year_str === '' && $text_str === '') {
        continue;
      }
      $milestones[] = [
        'year' => $year_str,
        'text' => $text_str,
      ];
    }

    if ($milestones !== []) {
      usort($milestones, static function (array $a, array $b): int {
        return strcmp($a['year'], $b['year']);
      });
    }
  }

  if ($milestones === []) {
    $form_state->setErrorByName('timeline_ui][add_person][milestones_json', t('Milestones JSON must include at least one entry.'));
    return;
  }

  //4.- Share the sanitized payload with the submit handler.
  $form_state->set('pds_recipe_timeline_add_person_new_person', [
    'name' => $name,
    'role' => $role,
    'milestones' => $milestones,
  ]);
}

/**
 * Detects if an array uses consecutive numeric keys starting at zero.
 */
function pds_recipe_timeline_is_list(array $array): bool {
  //1.- Prefer PHP's native helper when available.
  if (function_exists('array_is_list')) {
    return array_is_list($array);
  }

  //2.- Manual fallback for older runtimes.
  $expected = 0;
  foreach ($array as $key => $_value) {
    if ($key !== $expected) {
      return FALSE;
    }
    $expected++;
  }

  return TRUE;
}

/**
 * Converts mixed values into a strict boolean.
 */
function pds_recipe_timeline_cast_bool($value, bool $default = FALSE): bool {
  //1.- Direct booleans are returned untouched.
  if (is_bool($value)) {
    return $value;
  }

  //2.- Numeric strings or integers treat non-zero as TRUE.
  if (is_numeric($value)) {
    return ((int) $value) !== 0;
  }

  //3.- Support common textual truthy/falsey values.
  if (is_string($value)) {
    $normalized = strtolower(trim($value));
    if ($normalized === '') {
      return $default;
    }
    if (in_array($normalized, ['1', 'true', 'yes', 'y', 'on', 'principal'], TRUE)) {
      return TRUE;
    }
    if (in_array($normalized, ['0', 'false', 'no', 'n', 'off'], TRUE)) {
      return FALSE;
    }
  }

  return $default;
}

/**
 * Cast various numeric inputs ("12", "12.5", "12,5") to float.
 */
function pds_recipe_timeline_parse_numeric($value): ?float {
  //1.- Null or empty values are ignored.
  if ($value === NULL || $value === '') {
    return NULL;
  }

  //2.- Existing numerics convert directly.
  if (is_numeric($value)) {
    return (float) $value;
  }

  //3.- Normalize decimal separators for string inputs.
  if (is_string($value)) {
    $normalized = str_replace(',', '.', trim($value));
    if ($normalized === '') {
      return NULL;
    }
    if (is_numeric($normalized)) {
      return (float) $normalized;
    }
  }

  return NULL;
}
