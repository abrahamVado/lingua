<?php

if (!function_exists('pds_recipe_avisos_normativos_register_runtime_autoloader')) {
  /**
   * Register a PSR-4 autoloader for the module during manual deployments.
   */
  function pds_recipe_avisos_normativos_register_runtime_autoloader(): void {
    static $registered = FALSE;

    //1.- Ensure the autoloader only runs once per request to avoid duplicates.
    if ($registered) {
      return;
    }

    $registered = TRUE;

    $base_directory = __DIR__ . '/src/';

    //2.- Skip the registration when the expected src directory is missing.
    if (!is_dir($base_directory)) {
      return;
    }

    spl_autoload_register(static function (string $class) use ($base_directory): void {
      //1.- Only handle classes that belong to the module's namespace prefix.
      $prefix = 'Drupal\\pds_recipe_avisos_normativos\\';
      if (strncmp($class, $prefix, strlen($prefix)) !== 0) {
        return;
      }

      //2.- Translate the remainder of the namespace into a filesystem path.
      $relative_class = substr($class, strlen($prefix));
      $relative_path = str_replace('\\', DIRECTORY_SEPARATOR, $relative_class) . '.php';

      //3.- Require the file when it exists so the class becomes available instantly.
      $candidate = $base_directory . $relative_path;
      if (is_readable($candidate)) {
        require_once $candidate;
      }
    });
  }
}

pds_recipe_avisos_normativos_register_runtime_autoloader();

if (!function_exists('pds_recipe_avisos_normativos_user_can_manage_template')) {
  /**
   * Determine whether the provided account can administer template records.
   */
  function pds_recipe_avisos_normativos_user_can_manage_template(?\Drupal\Core\Session\AccountInterface $account = NULL): bool {
    //1.- Default to the current user so callers inside controllers stay concise.
    if ($account === NULL) {
      $account = \Drupal::currentUser();
    }
    if (!$account) {
      return FALSE;
    }

    //2.- Allow traditional block admins and layout builder editors to interact with AJAX endpoints.
    $permissions = [
      'administer blocks',
      'administer layout builder',
      'configure any layout',
      'configure own layout',
      'configure all layout overrides',
      'configure editable layout overrides',
    ];

    foreach ($permissions as $permission) {
      if ($account->hasPermission($permission)) {
        return TRUE;
      }
    }

    //3.- Deny access when none of the relevant permissions are present.
    return FALSE;
  }
}

/**
 * @file
 * Hooks for pds_recipe_avisos_normativos.
 */

/**
 * Implements hook_theme().
 *
 * Registers the theme hook `pds_template_block`.
 * Maps it to templates/pds-avisos-normativos.html.twig.
 */
function pds_recipe_avisos_normativos_theme($existing, $type, $theme, $path) {
  return [
    'pds_template_block' => [
      'template' => 'pds-avisos-normativos', // looks for pds-avisos-normativos.html.twig
      'path' => $path . '/templates',
      'variables' => [
        'items' => [],
        'group_id' => NULL,
        'instance_uuid' => '',
      ],
    ],
  ];
}

if (!function_exists('pds_recipe_avisos_normativos_get_logger')) {
  /**
   * Provide a logger instance without assuming the container is ready.
   */
  function pds_recipe_avisos_normativos_get_logger(): ?\Drupal\Core\Logger\LoggerChannelInterface {
    static $logger;
    static $initialized = FALSE;

    //1.- Avoid repeated lookups so repeated helper calls stay efficient.
    if ($initialized) {
      return $logger;
    }

    $initialized = TRUE;

    try {
      //2.- Ask Drupal for the module channel when the logger factory service exists.
      if (method_exists('\Drupal', 'logger')) {
        $logger = \Drupal::logger('pds_recipe_avisos_normativos');
      }
    }
    catch (\Throwable $throwable) {
      //3.- Suppress bootstrap errors because fallback logic should never fatally fail.
      $logger = NULL;
    }

    return $logger;
  }
}

if (!function_exists('pds_recipe_avisos_normativos_include_service_class')) {
  /**
   * Attempt to include a service class when the autoloader cannot find it.
   */
  function pds_recipe_avisos_normativos_include_service_class(string $class, string $relative_path): bool {
    //1.- Skip all work when the caller already loaded the class in this request.
    if (class_exists($class, FALSE)) {
      return TRUE;
    }

    $logger = pds_recipe_avisos_normativos_get_logger();

    //2.- Prime the runtime class loader with the module namespace so Composer knows the mapping.
    if (defined('DRUPAL_ROOT') && method_exists('\\Drupal', 'hasService') && \Drupal::hasService('class_loader')) {
      try {
        $class_loader = \Drupal::service('class_loader');
        if (is_object($class_loader) && method_exists($class_loader, 'addPsr4')) {
          //3.- Register the PSR-4 path dynamically to cover manual module deployments.
          $class_loader->addPsr4('Drupal\\pds_recipe_avisos_normativos\\', __DIR__ . '/src');
        }
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to register PSR-4 mapping for @class: @message', [
            '@class' => $class,
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //4.- Look inside the module directory directly so cache rebuilds keep working.
    $paths = [__DIR__ . $relative_path];

    //5.- Resolve the module path from the extension list when the container is ready.
    if (defined('DRUPAL_ROOT') && method_exists('\Drupal', 'hasService') && \Drupal::hasService('extension.list.module')) {
      try {
        $module_path = \Drupal::service('extension.list.module')->getPath('pds_recipe_avisos_normativos');
        if (is_string($module_path) && $module_path !== '') {
          $paths[] = DRUPAL_ROOT . '/' . $module_path . $relative_path;
        }
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve module path while including @class: @message', [
            '@class' => $class,
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //6.- Attempt each candidate path until the class definition is available.
    foreach ($paths as $path) {
      if (!is_string($path) || $path === '') {
        continue;
      }
      if (!is_readable($path)) {
        continue;
      }

      try {
        require_once $path;
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to include @class from @path: @message', [
            '@class' => $class,
            '@path' => $path,
            '@message' => $throwable->getMessage(),
          ]);
        }
        continue;
      }

      if (class_exists($class, FALSE)) {
        return TRUE;
      }
    }

    //7.- Report whether the helper managed to load the class so callers can fallback.
    return class_exists($class, FALSE);
  }
}

if (!function_exists('pds_recipe_avisos_normativos_create_row_image_promoter')) {
  /**
   * Factory callback so the container can instantiate the row image promoter.
   */
  function pds_recipe_avisos_normativos_create_row_image_promoter($entity_type_manager, $file_url_generator): object {
    $logger = pds_recipe_avisos_normativos_get_logger();

    //1.- Load the service class manually before the container tries to instantiate it.
    if (!pds_recipe_avisos_normativos_include_service_class('\\Drupal\\pds_recipe_avisos_normativos\\Service\\RowImagePromoter', '/src/Service/RowImagePromoter.php')) {
      if ($logger) {
        $logger->error('Unable to include row image promoter class while building the service container.');
      }
      throw new \RuntimeException('Missing RowImagePromoter class for pds_recipe_avisos_normativos.');
    }

    try {
      //2.- Return the fully constructed service instance to satisfy the container.
      return new \Drupal\pds_recipe_avisos_normativos\Service\RowImagePromoter(
        $entity_type_manager,
        $file_url_generator
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to create row image promoter service: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
      throw $throwable;
    }
  }
}

if (!function_exists('pds_recipe_avisos_normativos_create_legacy_schema_repairer')) {
  /**
   * Factory callback so the container can instantiate the schema repairer.
   */
  function pds_recipe_avisos_normativos_create_legacy_schema_repairer($connection, $time, $uuid, $logger_factory): object {
    $logger = pds_recipe_avisos_normativos_get_logger();

    //1.- Ensure the repairer class is available before dependency injection runs.
    if (!pds_recipe_avisos_normativos_include_service_class('\\Drupal\\pds_recipe_avisos_normativos\\Service\\LegacySchemaRepairer', '/src/Service/LegacySchemaRepairer.php')) {
      if ($logger) {
        $logger->error('Unable to include legacy schema repairer class while building the service container.');
      }
      throw new \RuntimeException('Missing LegacySchemaRepairer class for pds_recipe_avisos_normativos.');
    }

    try {
      //2.- Construct the repairer with its declared dependencies for the container.
      return new \Drupal\pds_recipe_avisos_normativos\Service\LegacySchemaRepairer(
        $connection,
        $time,
        $uuid,
        $logger_factory
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to create legacy schema repairer service: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
      throw $throwable;
    }
  }
}

if (!function_exists('pds_recipe_avisos_normativos_try_service')) {
  /**
   * Safely fetch a service from the container when possible.
   */
  function pds_recipe_avisos_normativos_try_service(string $service_id, ?string $log_message = NULL, array $context = []): ?object {
    //1.- Ensure the static container exists and knows about the requested service.
    if (!method_exists('\Drupal', 'hasService') || !\Drupal::hasService($service_id)) {
      return NULL;
    }

    try {
      //2.- Delegate to the container once it can provide the dependency.
      return \Drupal::service($service_id);
    }
    catch (\Throwable $throwable) {
      //3.- Emit the provided message so logs capture the root cause for administrators.
      if ($log_message) {
        $logger = pds_recipe_avisos_normativos_get_logger();
        if ($logger) {
          $context['@service'] = $service_id;
          $context['@message'] = $throwable->getMessage();
          $logger->error($log_message, $context);
        }
      }
      return NULL;
    }
  }
}

if (!function_exists('pds_recipe_avisos_normativos_ensure_group_and_get_id')) {
  /**
   * Ensure a template group exists for the provided UUID and return its id.
   */
  function pds_recipe_avisos_normativos_ensure_group_and_get_id(string $uuid, string $type = 'pds_recipe_avisos_normativos'): ?int {
    //1.- Reject empty UUIDs immediately so no database work happens without an identifier.
    if ($uuid === '') {
      return NULL;
    }

    $normalized_type = $type !== '' ? $type : 'pds_recipe_avisos_normativos';

    try {
      //2.- Attempt to reuse an existing active group row for this UUID.
      $connection = \Drupal::database();
      $existing_id = $connection->select('pds_template_group', 'g')
        ->fields('g', ['id'])
        ->condition('g.uuid', $uuid)
        ->condition('g.deleted_at', NULL, 'IS NULL')
        ->execute()
        ->fetchField();

      if ($existing_id) {
        return (int) $existing_id;
      }

      $now = \Drupal::time()->getRequestTime();

      try {
        //3.- Insert a fresh group row when the UUID has never been persisted before.
        $connection->insert('pds_template_group')
          ->fields([
            'uuid' => $uuid,
            'type' => $normalized_type,
            'created_at' => $now,
            'deleted_at' => NULL,
          ])
          ->execute();
      }
      catch (\Throwable $insert_exception) {
        //4.- Ignore duplicate key races because concurrent requests may create it too.
      }

      //5.- Resolve the identifier again to cover both inserts and duplicates gracefully.
      $new_id = $connection->select('pds_template_group', 'g')
        ->fields('g', ['id'])
        ->condition('g.uuid', $uuid)
        ->condition('g.deleted_at', NULL, 'IS NULL')
        ->execute()
        ->fetchField();

      return $new_id ? (int) $new_id : NULL;
    }
    catch (\Throwable $exception) {
      //6.- Fail softly so callers can fall back to configuration snapshots when DB errors appear.
      return NULL;
    }
  }
}

if (!function_exists('pds_recipe_avisos_normativos_resolve_row_image_promoter')) {
  /**
   * Resolve the row image promoter service even when the container is rebuilding.
   */
  function pds_recipe_avisos_normativos_resolve_row_image_promoter(): ?object {
    $promoter_class = '\\Drupal\\pds_recipe_avisos_normativos\\Service\\RowImagePromoter';

    $logger = pds_recipe_avisos_normativos_get_logger();

    //1.- Ensure the class definition exists before touching the service container.
    if (!pds_recipe_avisos_normativos_include_service_class($promoter_class, '/src/Service/RowImagePromoter.php')) {
      if ($logger) {
        $logger->error('Unable to locate row image promoter class.');
      }
      return NULL;
    }

    //2.- Prefer the container-managed service so dependency injection remains the primary path.
    if (method_exists('\Drupal', 'hasService') && \Drupal::hasService('pds_recipe_avisos_normativos.row_image_promoter')) {
      try {
        return \Drupal::service('pds_recipe_avisos_normativos.row_image_promoter');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to load row image promoter service: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //3.- Resolve required dependencies individually so cache rebuilds can still promote uploads.
    $entity_type_manager = pds_recipe_avisos_normativos_try_service(
      'entity_type.manager',
      'Unable to load @service while instantiating row image promoter: @message'
    );
    if (!$entity_type_manager && method_exists('\Drupal', 'entityTypeManager')) {
      try {
        //4.- Ask Drupal for the manager directly so manual deployments still resolve the dependency.
        $entity_type_manager = \Drupal::entityTypeManager();
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve entity type manager while instantiating row image promoter: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    $file_url_generator = pds_recipe_avisos_normativos_try_service(
      'file_url_generator',
      'Unable to load @service while instantiating row image promoter: @message'
    );
    if (!$file_url_generator && method_exists('\Drupal', 'service')) {
      try {
        //5.- Fall back to Drupal::service() so environments without hasService() still obtain the generator.
        $file_url_generator = \Drupal::service('file_url_generator');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve file URL generator while instantiating row image promoter: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    if (!$entity_type_manager || !$file_url_generator) {
      if ($logger) {
        $logger->error('Unable to build row image promoter manually because required services are missing.');
      }
      return NULL;
    }

    try {
      //6.- Instantiate the promoter directly when the container cannot provide it yet.
      return new \Drupal\pds_recipe_avisos_normativos\Service\RowImagePromoter(
        $entity_type_manager,
        $file_url_generator
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to instantiate row image promoter: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
    }

    //7.- Return NULL so callers can emit a helpful error response to editors.
    return NULL;
  }
}

if (!function_exists('pds_recipe_avisos_normativos_resolve_schema_repairer')) {
  /**
   * Resolve the schema repairer even when the service container is rebuilding.
   */
  function pds_recipe_avisos_normativos_resolve_schema_repairer(): ?object {
    $repairer_class = '\\Drupal\\pds_recipe_avisos_normativos\\Service\\LegacySchemaRepairer';

    $logger = pds_recipe_avisos_normativos_get_logger();

    //1.- Load the class manually when the autoloader cannot find it yet.
    if (!pds_recipe_avisos_normativos_include_service_class($repairer_class, '/src/Service/LegacySchemaRepairer.php')) {
      if ($logger) {
        $logger->error('Unable to locate schema repairer class.');
      }
      return NULL;
    }

    //2.- Prefer the registered service so requests benefit from shared state and caching.
    if (method_exists('\Drupal', 'hasService') && \Drupal::hasService('pds_recipe_avisos_normativos.legacy_schema_repairer')) {
      try {
        return \Drupal::service('pds_recipe_avisos_normativos.legacy_schema_repairer');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to load schema repairer service: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    //3.- Capture the dependencies individually so cache rebuilds can still repair tables.
    $time_service = pds_recipe_avisos_normativos_try_service(
      'datetime.time',
      'Unable to load @service while instantiating schema repairer: @message'
    );
    if (!$time_service && method_exists('\Drupal', 'time')) {
      try {
        //4.- Use Drupal::time() when the container lookup is unavailable during cache rebuilds.
        $time_service = \Drupal::time();
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve time service while instantiating schema repairer: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    $uuid_service = pds_recipe_avisos_normativos_try_service(
      'uuid',
      'Unable to load @service while instantiating schema repairer: @message'
    );
    if (!$uuid_service && method_exists('\Drupal', 'service')) {
      try {
        //5.- Pull the UUID generator directly from Drupal::service() when hasService() is unavailable.
        $uuid_service = \Drupal::service('uuid');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve UUID service while instantiating schema repairer: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    $logger_factory = pds_recipe_avisos_normativos_try_service(
      'logger.factory',
      'Unable to load @service while instantiating schema repairer: @message'
    );
    if (!$logger_factory && method_exists('\Drupal', 'service')) {
      try {
        //6.- Defer to Drupal::service() so runtime repairs still obtain a logger channel factory.
        $logger_factory = \Drupal::service('logger.factory');
      }
      catch (\Throwable $throwable) {
        if ($logger) {
          $logger->error('Unable to resolve logger factory while instantiating schema repairer: @message', [
            '@message' => $throwable->getMessage(),
          ]);
        }
      }
    }

    if (!$time_service || !$uuid_service || !$logger_factory) {
      if ($logger) {
        $logger->error('Unable to build schema repairer manually because required services are missing.');
      }
      return NULL;
    }

    try {
      //7.- Instantiate the repairer directly to cover requests during container rebuilds.
      return new \Drupal\pds_recipe_avisos_normativos\Service\LegacySchemaRepairer(
        \Drupal::database(),
        $time_service,
        $uuid_service,
        $logger_factory
      );
    }
    catch (\Throwable $throwable) {
      if ($logger) {
        $logger->error('Unable to instantiate schema repairer manually: @message', [
          '@message' => $throwable->getMessage(),
        ]);
      }
    }

    //8.- Return NULL when both the service container and manual instantiation fail.
    return NULL;
  }
}
